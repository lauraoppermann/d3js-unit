<!DOCTYPE html>
<html>
<head>
  <script type="text/javascript" src="/unit/d3js/libs/d3.v3.min.js"></script>
  <script type="text/javascript" src="/unit/d3js/libs/jquery.js"></script>
  <style>
    body {
      font: Arial 12px;
      text-align: center;
      background-color: white;
    }

    .axis path, .axis line {
      fill: none;
      stroke: black;
      stroke-width: 1;
      shape-rendering: crispEdges;
    }
  </style>
</head>
<body>
  <div id="chart-container"></div>
  <button id="start" onclick="start()">Start</button>
</body>
<script type="text/javascript">

  var currDataPoint = 0;

  function getVisibleDatapoints(chart) {
    if (chart.visibleDatapointsLimit) {
      var begin = currDataPoint - chart.visibleDatapointsLimit < 0 ? 0 : currDataPoint - chart.visibleDatapointsLimit;
      var end = currDataPoint + 1;

      return chart.data.slice(begin, end);
    }

    return chart.data.slice(0, currDataPoint + 1);
  }

  var chart = <%- chart %>;

  chart.width = chart.width ? Number(chart.width) : 1024;
  chart.height = chart.height ? Number(chart.height): 768;
  chart.dataRefreshInterval = chart.dataRefreshInterval ? Number(chart.dataRefreshInterval) : 1000;
  chart.visibleDatapointsLimit = chart.visibleDatapointsLimit ? Number(chart.visibleDatapointsLimit) : null;
  chart.data = chart.data.map(function(d) {
	  d.x = Number(d.x);
		d.y = Number(d.y);
		d.radius = Number(d.radius);
    return d;
  });

  //Set margins and sizes
  var margin = {
    top: 20,
    bottom: 50,
    right: 30,
    left: 50
  };

  var width = chart.width;
  var height = chart.height;

  //Create x and y scale to scale inputs
	var xScale = d3.scale.linear().domain([chart.minX, chart.maxX]).range([0, width]);
	var yScale = d3.scale.linear().domain([chart.maxY, chart.minY]).range([0, height]);

  //Create x and y axes
	//Create x and y axes
	var xAxis = d3.svg.axis()
			.scale(xScale)
			.orient("bottom")
			.ticks(10)
			.tickSize(2,0);


	var yAxis = d3.svg.axis()
		.scale(yScale)
		.orient("left")
		.ticks(5)
		.tickSize(2,0)


	d3.selectAll(".xAxis>.tick")
    .each(function(d, i){
      d3.select(this).style("font-size","4px");
    });

  var data = chart.data;

  var visibleData = getVisibleDatapoints(chart);

  //Create an SVG element and append it to the DOM
  var svg = d3.select("#chart-container")
    .insert("svg:svg")
    .attr("id", "chart")
    .attr({"width": width + margin.left + margin.right, "height": height + margin.top + margin.bottom})
    .append("svg:g")
    .attr("transform","translate(" + margin.left + "," + margin.top + ")");

	svg.append("text")
        .attr("x", (width / 2))
        .attr("y", 0 - (margin.top / 2))
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .text(chart.title);

  svg.append("text")
      .attr("id", "timeStamp")
      .attr("x", (width / 2))
      .attr("y", margin.top+height)
      .attr("text-anchor", "middle")
      .style("font-size", "8px")
      .text(visibleData[currDataPoint].timeStamp);

	var path = svg.append('g')
    .selectAll("circle")
    .data(visibleData)
    .enter()
    .append("circle")
      .attr("cx", function (d) { return xScale(d.x) } )
      .attr("cy", function (d) { return yScale(d.y) } )
      .attr("r", function (d) { return (d.radius>0 ? (xScale(d.radius+d.x)-xScale(d.x)) : (xScale(0.2+d.x)-xScale(d.x)) )})
      .style("fill", function(d) {
      if(d.radius > 0){
       return "none";
      } else{
        return "#c26969";
      }
      })
      .style("stroke", function(d) {
      if(d.radius > 0){
       return "#8dd6d1";
      } else{
        return "none";
      }
      })
      .style("stroke-width", 0.5)

    //Add X Axis
  var x = svg.append("svg:g")
    .attr("transform", "translate(0," + height + ")")
    .attr("class", "x axis")
    .call(xAxis);

  //Add Y Axis
  var y = svg.append("svg:g")
    .call(yAxis)
    .attr("class", "y axis");

  //Add label to Y axis
  y.append("svg:text")
    .attr("fill", "#000")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", "0.71em")
    .attr("text-anchor", "end")
    .text("value");

  function rerender() {

    currDataPoint++;
		console.log(currDataPoint);

    visibleData = getVisibleDatapoints(chart);

    // Select the section we want to apply our changes to
    // var svg = d3.select("#chart").transition();

			var timeStamp = svg.select("#timeStamp").text(visibleData[currDataPoint].timeStamp);

			 var circle = svg.select("g").selectAll("circle").data(visibleData);

				 circle.exit().remove();//remove unneeded circles
				 circle.enter().append("circle")
										.attr("r",0);//create any new circles needed

				 // update all circles to new positions
				 circle.transition()
					.duration(chart.dataRefreshInterval)
					.attr("cx", function (d) { return xScale(d.x) } )
					.attr("cy", function (d) { return yScale(d.y) } )
					.attr("r", function (d) { return (d.radius>0 ? (xScale(d.radius+d.x)-xScale(d.x)) : (xScale(0.2+d.x)-xScale(d.x)) )})
					.style("fill", function(d) {
					if(d.radius > 0){
					 return "none";
					} else{
						return "#c26969";
					}
					})
					.style("stroke", function(d) {
					if(d.radius > 0){
					 return "#8dd6d1";
					} else{
						return "none";
					}
					})
					 .style("stroke-width", 0.5)
					 .each('end', onTransitionEnd);
  }

  function onTransitionEnd() {
    if (currDataPoint >= data.length - 1) {
      endTime = Date.now();
      console.log("data max reached");
      console.log(endTime - startTime);
      sendStopEvent();
    } else {
      rerender();
    }
  }

  var startTime;
  var endTime;

  function start() {
    $("#start").prop("disabled", true);
    startTime = Date.now();
    rerender();
  }

  function sendStopEvent() {
    window.callPhantom({
      command: 'exit',
      reason: 'finished animation'
    })
  }
</script>
</html>
